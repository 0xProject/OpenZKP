{
  "language": "Solidity",
  "sources": {
    "contracts/fri.sol": {
      "content": "pragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\nimport './public_coin.sol';\nimport './iterator.sol';\nimport './primefield.sol';\nimport './merkle.sol';\nimport './proof_types.sol';\nimport './utils.sol';\n\nimport '@nomiclabs/buidler/console.sol';\n\n\ncontract Fri is MerkleVerifier {\n    using PublicCoin for PublicCoin.Coin;\n    using Iterators for Iterators.IteratorUint;\n    using PrimeField for uint256;\n    using PrimeField for PrimeField.EvalX;\n    using PrimeField for uint256[];\n    using Utils for *;\n\n    struct FriContext {\n        uint256[][] fri_values;\n        bytes32[] fri_commitments;\n        bytes32[][] fri_decommitments;\n        uint8[] fri_layout;\n        uint256[] eval_points;\n        uint8 log_eval_domain_size;\n        uint64[] queries;\n        uint256[] polynomial_at_queries;\n        uint256[] last_layer_coefficients;\n    }\n\n    struct LayerContext {\n        uint64 coset_size;\n        uint64 step;\n        uint64 len;\n    }\n\n    // Reads from channel random and returns a list of random queries\n    function get_queries(PublicCoin.Coin memory coin, uint8 max_bit_length, uint8 num_queries)\n        internal\n        pure\n        returns (uint64[] memory)\n    {\n        uint64[] memory queries = new uint64[](num_queries);\n        // This mask sets all digits to one below the bit length\n        uint64 bit_mask = (uint64(2)**max_bit_length) - 1;\n\n        // We derive four queries from each read\n        for (uint256 i = 0; i <= num_queries / 4; i++) {\n            bytes32 random = coin.read_bytes32();\n            for (uint256 j = 0; j < 4; j++) {\n                // For numbers of queries which are not diviable by four this prevents writing out of bounds.\n                if (4 * i + j < num_queries) {\n                    // Note - uint64(random) would take the last bytes in the random and this takes the first.\n                    queries[4 * i + j] = uint64(bytes8(random)) & bit_mask;\n                    // Shifts down so we can get the next set of random bytes\n                    random <<= 64;\n                }\n            }\n        }\n        queries.sort();\n        return queries;\n    }\n\n    // Unwraping endpoint because the main function has too deep of a stack otherwise\n    function fri_check(\n        ProofTypes.StarkProof memory proof,\n        uint8[] memory fri_layout,\n        uint256[] memory eval_points,\n        uint8 log_eval_domain_size,\n        uint64[] memory queries,\n        uint256[] memory polynomial_at_queries\n    ) internal {\n        fold_and_check_fri_layers(\n            FriContext(\n                proof.fri_values,\n                proof.fri_commitments,\n                proof.fri_decommitments,\n                fri_layout,\n                eval_points,\n                log_eval_domain_size,\n                queries,\n                polynomial_at_queries,\n                proof.last_layer_coefficients\n            )\n        );\n    }\n\n    // This function takes in fri values, decommitments, and layout and checks the folding and merkle proofs\n    // Note the final layer folded values will be overwritten to the input data locations.\n    function fold_and_check_fri_layers(FriContext memory fri_data) internal {\n        PrimeField.EvalX memory eval = PrimeField.init_eval(fri_data.log_eval_domain_size);\n        LayerContext memory layer_context = LayerContext({\n            len: uint64(2)**(fri_data.log_eval_domain_size),\n            step: 1,\n            coset_size: 0\n        });\n        uint256[] memory merkle_indices = new uint256[](fri_data.queries.length);\n        bytes32[] memory merkle_val = new bytes32[](fri_data.queries.length);\n\n        for (uint256 i = 0; i < fri_data.fri_layout.length; i++) {\n            layer_context.coset_size = uint64(2)**(fri_data.fri_layout[i]);\n            // Overwrites and resizes the data array and the querry index array\n            // They will contain the folded points and indexes\n            fold_layer(\n                fri_data.polynomial_at_queries,\n                fri_data.queries,\n                Iterators.init_iterator(fri_data.fri_values[i]),\n                eval,\n                fri_data.eval_points[i],\n                layer_context,\n                merkle_val\n            );\n            // Merkle verification is in place but we need unchanged data in the next loop.\n            fri_data.queries.deep_copy_and_convert(merkle_indices);\n            // Since these two arrays only truncate we can safely resize them\n            if (fri_data.queries.length != merkle_indices.length) {\n                uint256 num_queries = fri_data.queries.length;\n                merkle_indices.truncate(num_queries);\n                merkle_val.truncate(num_queries);\n            }\n            // TODO - Consider abstracting it up to a (depth, index) format like in the rust code.\n            for (uint256 j = 0; j < merkle_indices.length; j++) {\n                merkle_indices[j] += (layer_context.len / uint64(layer_context.coset_size));\n            }\n            // We now check that the folded indices and values verify against their decommitment\n            require(\n                verify_merkle_proof(\n                    fri_data.fri_commitments[i],\n                    merkle_val,\n                    merkle_indices,\n                    fri_data.fri_decommitments[i]\n                ),\n                'Fri merkle verification failed'\n            );\n            layer_context.len /= uint64(layer_context.coset_size);\n            layer_context.step *= uint64(layer_context.coset_size);\n        }\n\n        // Looks up a root of unity in the final domain\n        uint256 interp_root = eval.lookup(eval.eval_domain_size / layer_context.len);\n\n        // We now test that the commited last layer values interpolate the final fri folding values\n        for (uint256 i = 0; i < fri_data.polynomial_at_queries.length; i++) {\n            uint8 layer_num_bits = layer_context.len.num_bits();\n            uint256 reversed_query = fri_data.queries[i].bit_reverse(layer_num_bits);\n            uint256 x = interp_root.fpow(reversed_query);\n            uint256 calculated = fri_data.last_layer_coefficients.horner_eval(x);\n            require(calculated == fri_data.polynomial_at_queries[i], 'Last layer coeffients mismatch');\n        }\n    }\n\n    // This function takes in a previous layer and fold and reads from it and writes new folded layers to the next layer.\n    // It will overwrite any memory in that location.\n    function fold_layer(\n        uint256[] memory previous_layer,\n        uint64[] memory previous_indicies,\n        Iterators.IteratorUint memory extra_coset_data,\n        PrimeField.EvalX memory eval_x,\n        uint256 eval_point,\n        LayerContext memory layer_context,\n        bytes32[] memory coset_hash_output\n    ) internal {\n        // Reads how many of the cosets we've read from\n        uint256 writes = 0;\n        uint64 current_index;\n        uint256[] memory next_coset = new uint256[](layer_context.coset_size);\n        uint256 i = 0;\n        while (i < previous_layer.length) {\n            current_index = previous_indicies[i];\n            // Each coset length elements in the domain are one coset, so to find which one the current index is\n            // we have to take it mod the length, to find the starting index we subtract the coset index from the\n            // current one.\n            uint64 min_coset_index = uint64((current_index) - (current_index % layer_context.coset_size));\n            for (uint64 j = 0; j < layer_context.coset_size; j++) {\n                // This check is if the current index is one which has data from the previous layer,\n                // or if it's one with data provided in the proof\n                if (current_index == j + min_coset_index) {\n                    // Set this coset's data to the previous layer data at this index\n                    next_coset[uint256(j)] = previous_layer[i];\n                    // Advance the index from the read\n                    i++;\n                    if (i < previous_indicies.length) {\n                        // Set the current index to the next one\n                        current_index = previous_indicies[i];\n                    }\n                } else {\n                    // This happens if the data isn't in the previous layer so we use our extra data.\n                    next_coset[uint256(j)] = extra_coset_data.next();\n                }\n            }\n            // Hash the coset and store it so we can do a merkle proof against it\n            coset_hash_output[writes] = merkleLeafHash(next_coset);\n            // Do the actual fold and write it to the next layer\n            previous_layer[writes] = fold_coset(next_coset, eval_point, layer_context, min_coset_index / 2, eval_x);\n            // Record the new index\n            previous_indicies[writes] = uint64(min_coset_index / layer_context.coset_size);\n            writes++;\n        }\n        previous_layer.truncate(writes);\n        previous_indicies.truncate(writes);\n    }\n\n    function fold_coset(\n        uint256[] memory coset,\n        uint256 eval_point,\n        LayerContext memory layer_context,\n        uint64 index,\n        PrimeField.EvalX memory eval_x\n    ) internal returns (uint256) {\n        // TODO - This could likely be one variable and the eval domain size in the layer context\n        uint64 len = layer_context.len;\n        uint64 step = layer_context.step;\n        uint256 current_len = coset.length;\n        while (current_len > 1) {\n            for (uint256 i = 0; i < current_len; i += 2) {\n                // We know that because this is a root of a power of two domain\n                // we can lookup the x inverse using the following index manipulation\n                // and power\n                uint256 x_inv;\n                {\n                    uint64 half_i_plus_index = uint64(i / 2) + index;\n                    uint8 half_length_bits = (len / 2).num_bits();\n                    uint256 half_i_plus_index_reversed = half_i_plus_index.bit_reverse(half_length_bits);\n                    uint256 inverse_index = eval_x.eval_domain_size - half_i_plus_index_reversed * step;\n                    inverse_index = inverse_index % eval_x.eval_domain_size;\n                    x_inv = eval_x.lookup(inverse_index);\n                }\n\n                // We now do the actual fri folding operation\n                uint256 f_x_plus_f_neg_x = coset[i].fadd(coset[i + 1]);\n                uint256 eval_point_div_x = x_inv.fmul(eval_point);\n                uint256 f_x_sub_f_neg_x = coset[i].fsub(coset[i + 1]);\n                // Note - Both eval_point_div_x and f_x_sub_f_neg_x are montgomery so we\n                // have to use special multiplication\n                uint256 eval_over_x_times_f_x_sub_f_neg_x = eval_point_div_x.fmul_mont(f_x_sub_f_neg_x);\n                coset[i / 2] = f_x_plus_f_neg_x.fadd(eval_over_x_times_f_x_sub_f_neg_x);\n            }\n            len /= 2;\n            index /= 2;\n            step *= 2;\n            eval_point = eval_point.fmul_mont(eval_point);\n            current_len /= 2;\n        }\n\n        // We return the fri folded point and the inverse for the base layer, which is our x_inv on the next level\n        return (coset[0]);\n    }\n}\n"
    },
    "contracts/public_coin.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport './primefield.sol';\n\n\nlibrary PublicCoin {\n    struct Coin {\n        bytes32 digest;\n        uint64 counter;\n    }\n\n    // Takes bytes to be written to the channel and writes them to the coin,\n    // Note that because this is a memory refrence this updates the coin.\n    function write_bytes32(Coin memory coin, bytes32 to_be_written) internal pure {\n        bytes32 hashed = publicCoinHash(coin.digest, to_be_written);\n        coin.counter = 0;\n        coin.digest = hashed;\n    }\n\n    // Writes a list of bytes32 with each bytes32 written individually\n    function write_many_bytes32(Coin memory coin, bytes32[] memory to_be_written) internal pure {\n        for (uint256 i = 0; i < to_be_written.length; i++) {\n            write_bytes32(coin, to_be_written[i]);\n        }\n    }\n\n    function write_many_field_elements(Coin memory coin, uint256[] memory to_be_written) internal pure {\n        for (uint256 i = 0; i < to_be_written.length; i++) {\n            bytes32 element = (bytes32)(to_be_written[i]);\n            write_bytes32(coin, element);\n        }\n    }\n\n    // Flexible method to write a byte string\n    function write_bytes(Coin memory coin, bytes memory to_be_written) internal pure {\n        bytes32 new_hash = publicCoinHasher(abi.encodePacked(coin.digest, to_be_written));\n        coin.digest = new_hash;\n        coin.counter = 0;\n    }\n\n    // Uses the digest and counter of the coin to create a random number\n    // Note that because this is a memory refrence this updates the coin.\n    function read_bytes32(Coin memory coin) internal pure returns (bytes32) {\n        bytes32 hashed = publicCoinHash(coin.digest, bytes32(uint256(coin.counter)));\n        coin.counter++;\n        return hashed;\n    }\n\n    function read_field_element(Coin memory coin) internal pure returns (uint256) {\n        uint256 result = (uint256)(read_bytes32(coin));\n        result &= PrimeField.MODULUS_MASK;\n        while (result >= PrimeField.MODULUS) {\n            result = (uint256)(read_bytes32(coin));\n            result &= PrimeField.MODULUS_MASK;\n        }\n        return result;\n    }\n\n    function read_many_field_elements(Coin memory coin, uint256 how_many) internal pure returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](how_many);\n        for (uint256 i = 0; i < how_many; i++) {\n            result[i] = read_field_element(coin);\n        }\n        return result;\n    }\n\n    // Bulk Read, reads 'how_many' times\n    function read_many_bytes32(Coin memory coin, uint256 how_many) internal pure returns (bytes32[] memory) {\n        bytes32[] memory result = new bytes32[](how_many);\n        for (uint256 i = 0; i < how_many; i++) {\n            result[i] = read_bytes32(coin);\n        }\n    }\n\n    // Adds a new coin with the starting bytes of data hashed to form the digest.\n    function init_coin(bytes memory starting_data) internal pure returns (Coin memory) {\n        bytes32 hashed = publicCoinHasher(starting_data);\n        Coin memory new_coin;\n        new_coin.digest = hashed;\n        return new_coin;\n    }\n\n    function publicCoinHash(bytes32 preimage_a, bytes32 preimage_b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(preimage_a, preimage_b));\n    }\n\n    function publicCoinHasher(bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(data));\n    }\n}\n"
    },
    "contracts/primefield.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\nlibrary PrimeField {\n    uint256 internal constant MODULUS = 0x0800000000000011000000000000000000000000000000000000000000000001;\n    uint256 internal constant MODULUS_MASK = 0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 internal constant MONTGOMERY_R = 0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1;\n    uint256 internal constant MONTGOMERY_R_INV = 0x40000000000001100000000000012100000000000000000000000000000000;\n    uint256 internal constant GENERATOR = 3;\n    uint256 internal constant ONE = 1;\n\n    function from_montgomery(uint256 value) internal pure returns (uint256) {\n        return mulmod(value, MONTGOMERY_R_INV, MODULUS);\n    }\n\n    function from_montgomery_bytes(bytes32 bs) internal pure returns (uint256) {\n        return from_montgomery(uint256(bs));\n    }\n\n    // This is an unchecked cast and should be used very carefully,\n    // and only in cases when the data is already in the right form.\n    function from_bytes_array_raw(bytes32[] memory input) internal pure returns (uint256[] memory data) {\n        assembly {\n            data := input\n        }\n    }\n\n    function to_montgomery(uint256 value) internal pure returns (uint256) {\n        return mulmod(value, MONTGOMERY_R, MODULUS);\n    }\n\n    function fmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mulmod(a, b, MODULUS);\n    }\n\n    function fmul_mont(uint256 a, uint256 b) internal pure returns (uint256) {\n        return fmul(fmul(a, b), MONTGOMERY_R_INV);\n    }\n\n    function fadd(uint256 a, uint256 b) internal pure returns (uint256) {\n        return addmod(a, b, MODULUS);\n    }\n\n    function fsub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return addmod(a, MODULUS - b, MODULUS);\n    }\n\n    function fpow(uint256 value, uint256 exp) internal returns (uint256) {\n        return expmod(value, exp, MODULUS);\n    }\n\n    // There's still no native call to the exp mod precompile in solidity\n    function expmod(uint256 base, uint256 exponent, uint256 modulus) internal returns (uint256 result) {\n        // TODO - Check if gas is based on absolute input length or on indicated length\n        // that will have massive gas implications [13k for a square vs 50]\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20) // Length of Base\n            mstore(add(p, 0x20), 0x20) // Length of Exponent\n            mstore(add(p, 0x40), 0x20) // Length of Modulus\n            mstore(add(p, 0x60), base) // Base\n            mstore(add(p, 0x80), exponent) // Exponent\n            mstore(add(p, 0xa0), modulus) // Modulus\n            // call modexp precompile\n            if iszero(call(not(0), 0x05, 0, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            result := mload(p)\n        }\n    }\n\n    function inverse(uint256 value) internal returns (uint256) {\n        // The expmod version here costs 13758 gas\n        return expmod(value, MODULUS - 2, MODULUS);\n    }\n\n    // Reverts if unavailable\n    function generator_power(uint8 log_order) internal returns (uint256) {\n        uint256 maybe_exact = (MODULUS - 1) / (uint256(2)**log_order);\n        require(maybe_exact * (uint256(2)**log_order) == (MODULUS - 1), 'Root unavailable');\n        return expmod(GENERATOR, maybe_exact, MODULUS);\n    }\n\n    // We assume that the coeffients are in montgomery form, but that x is not\n    function horner_eval(uint256[] memory coefficents, uint256 x) internal pure returns (uint256) {\n        require(coefficents.length > 0, \"Evaluation undefined\");\n        uint256 b = 0;\n        for (uint256 i = coefficents.length - 1; i > 0; i--) {\n            b = fadd(coefficents[i], fmul(b, x));\n        }\n        return fadd(coefficents[0], fmul(b, x));\n    }\n\n    // The EvalX struct will lookup powers of x inside of the eval domain\n    // It simplifies the interface, and can be made much more gas efficent\n    struct EvalX {\n        uint256 eval_domain_generator;\n        uint8 log_eval_domain_size;\n        uint64 eval_domain_size;\n    }\n\n    // Lookup data at an index\n    // These lookups cost around 530k of gas overhead in the small fib proof\n    function lookup(EvalX memory eval_x, uint256 index) internal returns (uint256) {\n        return fpow(eval_x.eval_domain_generator, index);\n    }\n\n    // Returns a memory object which allows lookups\n    function init_eval(uint8 log_eval_domain_size) internal returns (EvalX memory) {\n        return\n            EvalX(\n                PrimeField.generator_power(log_eval_domain_size),\n                log_eval_domain_size,\n                uint64(2)**(log_eval_domain_size)\n            );\n    }\n}\n"
    },
    "contracts/iterator.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\nlibrary Iterators {\n    // This memory pointer contains an index and a refrence to data\n    // It will work as an iterator with a .next() function which returns\n    // the next data, and a .has_next() which returns a bool;\n    // NOTE - No solidity generics means we will need iterators for each type.\n    struct IteratorBytes32 {\n        uint256 index;\n        bytes32[] data_pointer;\n    }\n\n    // Creates a memory refrence to an interator which starts at the front of\n    // this array.\n    function init_iterator(bytes32[] memory data) internal pure returns (IteratorBytes32 memory result) {\n        result.data_pointer = data;\n        result.index = 0;\n    }\n\n    // Returns the next element in the array or reverts if called on an empty iterator.\n    function next(IteratorBytes32 memory iterator) internal pure returns (bytes32) {\n        iterator.index++;\n        return iterator.data_pointer[iterator.index - 1];\n    }\n\n    // Returns a bool indicating that this iterator has a next element.\n    function has_next(IteratorBytes32 memory iterator) internal pure returns (bool) {\n        return iterator.index < iterator.data_pointer.length;\n    }\n\n    struct IteratorUint {\n        uint256 index;\n        uint256[] data_pointer;\n    }\n\n    // Creates a memory refrence to an interator which starts at the front of\n    // this array.\n    function init_iterator(uint256[] memory data) internal pure returns (IteratorUint memory result) {\n        result.data_pointer = data;\n        result.index = 0;\n    }\n\n    // Returns the next element in the array or reverts if called on an empty iterator.\n    function next(IteratorUint memory iterator) internal pure returns (uint256) {\n        iterator.index++;\n        return iterator.data_pointer[iterator.index - 1];\n    }\n\n    // Returns a bool indicating that this iterator has a next element.\n    function has_next(IteratorUint memory iterator) internal pure returns (bool) {\n        return iterator.index < iterator.data_pointer.length;\n    }\n}\n"
    },
    "contracts/merkle.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport './ring_buffer.sol';\nimport './iterator.sol';\n\n\ncontract MerkleVerifier {\n    using RingBuffer for RingBuffer.IndexRingBuffer;\n    using Iterators for Iterators.IteratorBytes32;\n\n    // This function takes a set of data leaves and indices are 2^depth + leaf index and must be sorted in ascending order.\n    // NOTE - An empty claim will revert\n    function verify_merkle_proof(\n        bytes32 root,\n        bytes32[] memory leaves,\n        uint256[] memory indices,\n        bytes32[] memory decommitment\n    ) internal pure returns (bool) {\n        require(leaves.length > 0, 'No claimed data');\n        // Setup our index buffer\n        RingBuffer.IndexRingBuffer memory buffer = RingBuffer.IndexRingBuffer({\n            front: 0,\n            back: leaves.length - 1,\n            indexes: indices,\n            data: leaves,\n            is_empty: false\n        });\n        // Setup our iterator\n        Iterators.IteratorBytes32 memory decommitment_iter = Iterators.init_iterator(decommitment);\n\n        while (true) {\n            (uint256 index, bytes32 current_hash) = buffer.remove_front();\n\n            // If the index is one this node is the root so we need to check if the proposed root matches\n            if (index == 1) {\n                return (root == current_hash);\n            }\n\n            bool is_left = index % 2 == 0;\n            bool needs_new_node = true;\n            // If this is a left node then the node following it in the queue\n            // may be a sibbling which we want to hash with it.\n            if (is_left) {\n                // If it exists we peak at the next node in the queue\n                if (buffer.has_next()) {\n                    (uint256 next_index, bytes32 next_hash) = buffer.peak_front();\n\n                    // This checks if the next index in the queue is the sibbling of this one\n                    // If it is we use the data, otherwise we try the decommitment queue\n                    if (next_index == index + 1) {\n                        // This force increments the front, may consider real method for this.\n                        (next_index, next_hash) = buffer.remove_front();\n\n                        // Because index is even it is the left hash so to get the next one we do:\n                        bytes32 new_hash = merkleTreeHash(current_hash, next_hash);\n                        buffer.add_to_rear(index / 2, new_hash);\n                        // We indicate that a node was pushed, so that another won't be\n                        needs_new_node = false;\n                    }\n                }\n            }\n\n            // Next we try to read from the decommitment and use that info to push a new hash into the queue\n            if (needs_new_node) {\n                // If we don't have more decommitment the proof fails\n                if (!decommitment_iter.has_next()) {\n                    return false;\n                }\n                // Reads from decommitment and pushes a new node\n                read_decommitment_and_push(is_left, buffer, decommitment_iter, current_hash, index);\n            }\n        }\n    }\n\n    // This function reads from decommitment and pushes the new node onto the buffer,\n    // It returns true if decommitment data exists and false if it doesn't.\n    function read_decommitment_and_push(\n        bool is_left,\n        RingBuffer.IndexRingBuffer memory buffer,\n        Iterators.IteratorBytes32 memory decommitment,\n        bytes32 current_hash,\n        uint256 index\n    ) internal pure {\n        bytes32 next_decommitment = decommitment.next();\n        bytes32 new_hash;\n        // Preform the hash\n        if (is_left) {\n            new_hash = merkleTreeHash(current_hash, next_decommitment);\n        } else {\n            new_hash = merkleTreeHash(next_decommitment, current_hash);\n        }\n        // Add the new node to the buffer.\n        // Note the buffer strictly shrinks in the algo so we can't overflow the size.\n        buffer.add_to_rear(index / 2, new_hash);\n    }\n\n    bytes32 constant HASH_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;\n\n    function merkleTreeHash(bytes32 preimage_a, bytes32 preimage_b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(preimage_a, preimage_b)) & HASH_MASK;\n    }\n\n    function merkleLeafHash(uint256[] memory leaf) internal pure returns (bytes32) {\n        if (leaf.length == 1) {\n            return (bytes32)(leaf[0]);\n        } else {\n            return keccak256(abi.encodePacked(leaf)) & HASH_MASK;\n        }\n    }\n}\n"
    },
    "contracts/ring_buffer.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\nlibrary RingBuffer {\n    // This struct is a queeue with a fixed length, reading indexed pairs.\n    // NOTE - This struct does NOT implement bounds checking, pushing\n    // too much into the array will result in memory corruption.\n    // NOTE - Reading an empty buffer returns zero values.\n    struct IndexRingBuffer {\n        uint256 front;\n        uint256 back;\n        uint256[] indexes;\n        bytes32[] data;\n        bool is_empty;\n    }\n\n    // Adds an element to the buffer by pushing to the array and\n    // and wrapping around if the back is at the end of the array.\n    function add_to_rear(IndexRingBuffer memory buffer, uint256 index, bytes32 data) internal pure {\n        // If the buffer is empty set it to a single element state.\n        // Otherwise we push and move the back index mod the length.\n        if (buffer.is_empty) {\n            buffer.front = 0;\n            buffer.back = 0;\n            buffer.is_empty = false;\n            buffer.indexes[0] = index;\n            buffer.data[0] = data;\n        } else {\n            // We could add a check here that the push doesn't put the buffer into\n            // the state where front = back, but we don't want reverts here.\n            uint256 next = (buffer.back + 1) % buffer.data.length;\n            buffer.data[next] = data;\n            buffer.indexes[next] = index;\n            buffer.back = next;\n        }\n    }\n\n    // Removes an element from the front of the buffer, and moves the front forward.\n    function remove_front(IndexRingBuffer memory buffer) internal pure returns (uint256 index, bytes32 data) {\n        // If the buffer is empty return 0, 0\n        if (buffer.is_empty) {\n            return (0, 0);\n        }\n\n        // Loads the return data\n        (index, data) = peak_front(buffer);\n        if (buffer.front == buffer.back) {\n            // If we are in a single element state and we remove the element it's now empty.\n            buffer.is_empty = true;\n        } else {\n            // Otherwise we move the front forward, cutting out the element\n            buffer.front = (buffer.front + 1) % buffer.data.length;\n        }\n    }\n\n    // Returns a copy of the next index pair\n    function peak_front(IndexRingBuffer memory buffer) internal pure returns (uint256 index, bytes32 data) {\n        // Return zero for the empty buffer\n        if (buffer.is_empty) {\n            return (0, 0);\n        }\n        // Otherwise just load the data\n        data = buffer.data[buffer.front];\n        index = buffer.indexes[buffer.front];\n    }\n\n    // Checks if the ring buffer contains anything, by checking if the front is the back\n    function has_next(IndexRingBuffer memory buffer) internal pure returns (bool) {\n        return !buffer.is_empty;\n    }\n}\n"
    },
    "contracts/proof_types.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\n\ncontract ProofTypes {\n    // This struct contains all of the components of the STARK proof.\n    // Please note that any input which would be a 'FieldElement' in rust\n    // should be the montgomery bytes encoded field element\n    // TODO - Add more structure\n    struct StarkProof {\n        // An array with the public inputs to the STARK\n        bytes public_inputs;\n        // An array with the flattened trace table decommitments\n        // For a trace table with n coloums it will be length num_queries*n\n        // and it will be laid out as:\n        // [[query 1 col 1][query 1 col 2]...[query 1 col n]]...[[query q col 1]...[query q col n]]\n        uint256[] trace_values;\n        // The commitment to the trace table\n        bytes32 trace_commitment;\n        // The trace table evaluated constraint values at the the query indices.\n        // This is also stored as a flattened array\n        uint256[] constraint_values;\n        // The commitment to the evaluated constraints\n        bytes32 constraint_commitment;\n        // The trace values used for the oods point constraint evaluation\n        uint256[] trace_oods_values;\n        // The constraint values used for the oods point constraint evaluation\n        uint256[] constraint_oods_values;\n        // The nonce used for the proof of work\n        bytes8 pow_nonce;\n        // The merkle decomitment for the trace values\n        bytes32[] trace_decommitment;\n        // The merkle decomitment for the constraint evaluated queries\n        bytes32[] constraint_decommitment;\n        // The values to complete each coset of fri at each layer.\n        uint256[][] fri_values;\n        // The roots for each fri decommitment\n        bytes32[] fri_commitments;\n        // The merkle proof decommitment at each fri layer\n        bytes32[][] fri_decommitments;\n        // The coeffiencts of the last fri layer\n        uint256[] last_layer_coefficients;\n    }\n\n    // This struct contains the relevent information about the constraint system\n    // It will be returned from a callout to the constraint system contract.\n    struct ProofParameters {\n        uint8 number_of_columns;\n        uint8 log_trace_length;\n        uint64 number_of_constraints;\n        uint8 log_blowup;\n        uint8 constraint_degree;\n        uint8 pow_bits;\n        uint8 number_of_queries;\n        // TODO - Does the smaller size give us a real advantage\n        uint8[] fri_layout;\n    }\n}\n"
    },
    "contracts/utils.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\nlibrary Utils {\n    function bit_reverse(uint64 num, uint8 number_of_bits) internal pure returns (uint256 num_reversed) {\n        uint64 n = num;\n        uint64 r = 0;\n        for (uint8 k = 0; k < number_of_bits; k++) {\n            r = (r * 2) | (n % 2);\n            n = n / 2;\n        }\n        return r;\n    }\n\n    function num_bits(uint64 data) internal pure returns (uint8) {\n        uint8 result = 0;\n        if (data >= (1 << 32)) {\n            result += 32;\n            data >>= 32;\n        }\n        if (data >= (1 << 16)) {\n            result += 16;\n            data >>= 16;\n        }\n        if (data >= (1 << 8)) {\n            result += 8;\n            data >>= 8;\n        }\n        if (data >= (1 << 4)) {\n            result += 4;\n            data >>= 4;\n        }\n        if (data >= (1 << 2)) {\n            result += 2;\n            data >>= 2;\n        }\n        if (data >= 2) {\n            result += 1;\n            data >>= 1;\n        }\n        return result + uint8(data) - 1;\n    }\n\n    function deep_copy(bytes32[] memory a, bytes32[] memory b) internal pure {\n        for (uint256 i = 0; i < a.length; i++) {\n            b[i] = a[i];\n        }\n    }\n\n    function deep_copy_and_convert(uint64[] memory a, uint256[] memory b) internal pure {\n        for (uint256 i = 0; i < a.length; i++) {\n            b[i] = a[i];\n        }\n    }\n\n    // This function sorts the array\n    // Note - We use insertion sort, the array is expected to be small so this shouldn't\n    // cause problems.\n    function sort(uint64[] memory data) internal pure {\n        for (uint256 i = 0; i < data.length; i++) {\n            uint256 j = i;\n            while (j > 0 && data[j] < data[j - 1]) {\n                (data[j], data[j - 1]) = (data[j - 1], data[j]);\n                j--;\n            }\n        }\n    }\n\n    // The following functions resize a memory array by reseting the\n    // first element of the array in memory, which as per this documentation\n    // https://solidity.readthedocs.io/en/v0.6.4/assembly.html#conventions-in-solidity\n    // is the place where the length is stored.\n    // It will revert if the method is called in a way which would expand memory\n    // because that would likely cause memory corruption.\n    // âš ï¸ WARNING âš ï¸ - This method is not guaranteed to work and\n    // any changes should be carefully considered â˜¢ï¸ â˜¢ï¸ðŸ’¥ðŸ’¥â˜¢ï¸ â˜¢ï¸\n    function truncate(bytes32[] memory data, uint256 to_len) internal pure {\n        require(data.length >= to_len, 'Shrink Failed');\n        assembly {\n            mstore(data, to_len)\n        }\n    }\n\n    // Type alias of the above function\n    function truncate(uint256[] memory data, uint256 to_len) internal pure {\n        require(data.length >= to_len, 'Shrink Failed');\n        assembly {\n            mstore(data, to_len)\n        }\n    }\n\n    // Type alias of the above function\n    function truncate(uint64[] memory data, uint256 to_len) internal pure {\n        require(data.length >= to_len, 'Shrink Failed');\n        assembly {\n            mstore(data, to_len)\n        }\n    }\n}\n"
    },
    "@nomiclabs/buidler/console.sol": {
      "content": "pragma solidity >= 0.5.0 <0.7.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n}\n"
    },
    "contracts/interfaces/ConstraintInterface.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport '../stark_verifier.sol';\nimport '../proof_types.sol';\n\n\ninterface ConstraintSystem {\n    // The function should return a constraint paramters struct based on the public input.\n    function initalize_system(bytes calldata public_input)\n        external\n        view\n        returns (ProofTypes.ProofParameters memory, PublicCoin.Coin memory);\n\n    // This function should take all of the relevent function information and then return two things\n    // (1) the evaulation of the constraints on the oods point and\n    // (2) the calculation of the points on the polynomial which is commited too for fri\n    function constraint_calculations(\n        ProofTypes.StarkProof calldata proof,\n        ProofTypes.ProofParameters calldata params,\n        uint64[] calldata queries,\n        uint256 oods_point,\n        uint256[] calldata constraint_coeffiencts,\n        uint256[] calldata oods_coeffiencts\n    ) external returns (uint256[] memory, uint256);\n}\n"
    },
    "contracts/stark_verifier.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/ConstraintInterface.sol';\nimport './public_coin.sol';\nimport './proof_of_work.sol';\nimport './fri.sol';\nimport './proof_types.sol';\nimport './utils.sol';\n\nimport '@nomiclabs/buidler/console.sol';\n\n\ncontract StarkVerifier is ProofOfWork, Fri, ProofTypes {\n    using PublicCoin for PublicCoin.Coin;\n    using Utils for *;\n\n    // TODO - Figure out why making this external causes 'UnimplementedFeatureError' only when\n    // it calls through to an internal function with proof as memory.\n    // Profiling - 687267 gas used by the call and copy into memory\n    // Profiling - 436384 gas used when the proof isn't copied into memory,\n    // making the memory copy much higher than estimates\n    function verify_proof(StarkProof memory proof, ConstraintSystem constraints) public returns (bool) {\n        // Initalize the coin and constraint system\n        (ProofParameters memory constraint_parameters, PublicCoin.Coin memory coin) = constraints.initalize_system(\n            proof.public_inputs\n        );\n        // Write data to the coin and read random data from it\n        // Profiling - uses around 30k gas\n        (\n            uint256[] memory constraint_coeffiencents,\n            uint256 oods_point,\n            uint256[] memory oods_coefficients,\n            uint256[] memory eval_points\n        ) = write_data_and_read_random(proof, constraint_parameters, coin);\n        // Preform the proof of work check\n        require(check_proof_of_work(coin, proof.pow_nonce, constraint_parameters.pow_bits), 'POW Failed');\n        // Read the query indices from the coin\n        uint8 eval_domain_log_size = constraint_parameters.log_trace_length + constraint_parameters.log_blowup;\n        uint64[] memory queries = get_queries(coin, eval_domain_log_size, constraint_parameters.number_of_queries);\n        // Get the actual polynomial points which were commited too, and the inverses of the x_points where they were evaluated\n        // Profiling - uses 266873 gas extra for this call with data as compared to without\n        (uint256[] memory fri_top_layer, uint256 constraint_evaluated_oods_point) = constraints.constraint_calculations(\n            proof,\n            constraint_parameters,\n            queries,\n            oods_point,\n            constraint_coeffiencents,\n            oods_coefficients\n        );\n\n        uint8 log_eval_domain_size = constraint_parameters.log_trace_length + constraint_parameters.log_blowup;\n        check_commitments(proof, constraint_parameters, queries, log_eval_domain_size);\n\n        // Profiling - 1086362 gas used for small fib before this call [includes the 250k used by the callout]\n        fri_check(proof, constraint_parameters.fri_layout, eval_points, log_eval_domain_size, queries, fri_top_layer);\n\n        check_out_of_domain_sample_result(proof, oods_point, constraint_evaluated_oods_point);\n    }\n\n    // This function write to the channel and reads from the channel to get the randomized data\n    function write_data_and_read_random(\n        StarkProof memory proof,\n        ProofParameters memory constraint_parameters,\n        PublicCoin.Coin memory coin\n    )\n        internal\n        pure\n        returns (\n            uint256[] memory constraint_coeffiencents,\n            uint256 oods_point,\n            uint256[] memory oods_coefficients,\n            uint256[] memory eval_points\n        )\n    {\n        // Write the trace root to the coin\n        coin.write_bytes32(proof.trace_commitment);\n        // Read random constraint coefficentrs from the coin\n        constraint_coeffiencents = coin.read_many_field_elements(2 * constraint_parameters.number_of_constraints);\n        // Write the evaluated constraint root to the coin\n        coin.write_bytes32(proof.constraint_commitment);\n        // Read the oods point from the coin\n        oods_point = coin.read_field_element();\n        // Write the trace oods values to the coin\n        coin.write_many_field_elements(proof.trace_oods_values);\n        // Write the constraint oods values to the coin\n        coin.write_many_field_elements(proof.constraint_oods_values);\n        // Read the oods coeffients from the random coin\n        oods_coefficients = coin.read_many_field_elements(\n            proof.trace_oods_values.length + proof.constraint_oods_values.length\n        );\n\n        // Writes the fri merkle roots and reads eval points from the coin\n        eval_points = new uint256[](constraint_parameters.fri_layout.length);\n        for (uint256 i; i < constraint_parameters.fri_layout.length; i++) {\n            coin.write_bytes32(proof.fri_commitments[i]);\n            eval_points[i] = coin.read_field_element();\n        }\n        // Write the claimed last layer points a set of coeffient for the final layer fri check\n        // NOTE - This is a fri layer so we have to write the whole thing at once\n        coin.write_bytes(abi.encodePacked(proof.last_layer_coefficients));\n        return (constraint_coeffiencents, oods_point, oods_coefficients, eval_points);\n    }\n\n    // TODO - We can move the hashing abstraction into the merkle tree and avoid this extra allocation\n    // Profiling - Apears to add around 900k gas! even ~600k with the optimizer on!\n    function check_commitments(\n        StarkProof memory proof,\n        ProofParameters memory constraint_parameters,\n        uint64[] memory queries,\n        uint8 log_eval_domain_size\n    ) internal pure {\n        bytes32[] memory merkle_hashes = new bytes32[](constraint_parameters.number_of_queries);\n        uint256[] memory query_copy = new uint256[](queries.length);\n        uint256 eval_domain_size = uint256(2)**(log_eval_domain_size);\n\n        prepare_hashes_and_queries(\n            proof.trace_values,\n            uint256(constraint_parameters.number_of_columns),\n            queries,\n            eval_domain_size,\n            merkle_hashes,\n            query_copy\n        );\n        require(\n            verify_merkle_proof(proof.trace_commitment, merkle_hashes, query_copy, proof.trace_decommitment),\n            'Trace commitment proof failed'\n        );\n\n        prepare_hashes_and_queries(\n            proof.constraint_values,\n            uint256(constraint_parameters.constraint_degree),\n            queries,\n            eval_domain_size,\n            merkle_hashes,\n            query_copy\n        );\n        require(\n            verify_merkle_proof(proof.constraint_commitment, merkle_hashes, query_copy, proof.constraint_decommitment),\n            'Constraint commitment proof failed'\n        );\n    }\n\n    // Reads through the groups in the data and then hashes them and stores the hash in the output array\n    // Also copies the queries into the output and adjusts them to merkle tree indexes.\n    function prepare_hashes_and_queries(\n        uint256[] memory data_groups,\n        uint256 data_group_size,\n        uint64[] memory queries,\n        uint256 eval_domain_size,\n        bytes32[] memory output_hashes,\n        uint256[] memory output_queries\n    ) internal pure {\n        uint256[] memory group = new uint256[](data_group_size);\n        for (uint256 i = 0; i < data_groups.length / data_group_size; i++) {\n            for (uint256 j = 0; j < data_group_size; j++) {\n                group[j] = data_groups[i * data_group_size + j];\n            }\n            output_hashes[i] = merkleLeafHash(group);\n        }\n\n        queries.deep_copy_and_convert(output_queries);\n        // TODO - Go to depth indexing in merkle to remove this\n        for (uint256 i = 0; i < queries.length; i++) {\n            output_queries[i] = output_queries[i] + eval_domain_size;\n        }\n        delete group;\n    }\n\n    function check_out_of_domain_sample_result(\n        ProofTypes.StarkProof memory proof,\n        uint256 oods_point,\n        uint256 evaluated_oods_point\n    ) internal pure {\n        // The final check is that the constraints evaluated at the out of domain sample are\n        // equal to the values commited constraint values\n        uint256 result = 0;\n        uint256 power = uint256(1).to_montgomery();\n        for (uint256 i = 0; i < proof.constraint_oods_values.length; i++) {\n            uint256 oods_value_times_power = proof.constraint_oods_values[i].fmul_mont(power);\n            result = result.fadd(oods_value_times_power);\n            power = power.fmul_mont(oods_point);\n        }\n        require(result == evaluated_oods_point, 'Oods mismatch');\n    }\n}\n"
    },
    "contracts/proof_of_work.sol": {
      "content": "pragma solidity 0.6.4;\n\nimport './public_coin.sol';\n\n\ncontract ProofOfWork {\n    using PublicCoin for PublicCoin.Coin;\n\n    // Given a coin and a nonce hashes the random form the coin and checks that the proof of works passes\n    // NOTE - This function also advances the coin by writing the pow_nonce to it\n    function check_proof_of_work(PublicCoin.Coin memory coin, bytes8 pow_nonce, uint8 pow_bits)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes32 seed = keccak256(abi.encodePacked(hex'0123456789abcded', coin.digest, pow_bits));\n        bytes32 response = keccak256(abi.encodePacked(seed, pow_nonce));\n        coin.write_bytes(abi.encodePacked(pow_nonce));\n        uint256 treshold = uint256(-1) >> pow_bits;\n        return uint256(response) <= treshold;\n    }\n}\n"
    },
    "contracts/testing_contracts/fri_testing.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport '../fri.sol';\nimport '../primefield.sol';\n\n\ncontract FriTesting is Fri {\n    event log_bytes32(bytes32 data);\n\n    function fold_coset_external(\n        uint256[] calldata coset,\n        uint256 eval_point,\n        uint64 step,\n        uint64 index,\n        uint64 len,\n        PrimeField.EvalX calldata eval_x\n    ) external {\n        emit log_bytes32((bytes32)(fold_coset(coset, eval_point, LayerContext(0, step, len), index, eval_x)));\n    }\n\n    // TODO - Unused function path\n    function fri_layering_external(\n        ProofTypes.StarkProof memory proof,\n        uint8[] memory fri_layout,\n        uint256[] memory eval_points,\n        uint8 log_eval_domain_size,\n        uint64[] memory queries,\n        uint256[] memory polynomial_at_queries\n    ) public {\n        fri_check(proof, fri_layout, eval_points, log_eval_domain_size, queries, polynomial_at_queries);\n        // Because we use overwriting internal memory management this should now hold our outputs\n        for (uint256 i = 0; i < polynomial_at_queries.length; i++) {\n            emit log_bytes32((bytes32)(polynomial_at_queries[i]));\n        }\n    }\n}\n"
    },
    "contracts/testing_contracts/merkle_tester.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport '../merkle.sol';\n\n\ncontract MerkleVerifierTest is MerkleVerifier {\n    function verify_merkle_proof_external(\n        bytes32 root,\n        bytes32[] calldata data_points,\n        uint256[] calldata indices,\n        bytes32[] calldata decommitment\n    ) external pure returns (bool) {\n        return verify_merkle_proof(root, data_points, indices, decommitment);\n    }\n}\n"
    },
    "contracts/testing_contracts/pow_testing.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport '../proof_of_work.sol';\nimport '../public_coin.sol';\n\n\ncontract ProofOfWorkTesting is ProofOfWork {\n    function check_proof_of_work_external(bytes32 init_digest, bytes8 pow_nonce, uint8 pow_bits)\n        external\n        pure\n        returns (bool)\n    {\n        PublicCoin.Coin memory coin = PublicCoin.Coin({digest: init_digest, counter: 0});\n        return check_proof_of_work(coin, pow_nonce, pow_bits);\n    }\n}\n"
    },
    "contracts/testing_contracts/prime_field_tester.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport '../primefield.sol';\n\n\ncontract PrimeFieldTester {\n    using PrimeField for *;\n    event log_bytes32(bytes32 data);\n\n    function fpow_external(uint256 a, uint256 b) external {\n        emit log_bytes32(bytes32(a.fpow(b)));\n    }\n\n    function inverse_external(uint256 a) external {\n        emit log_bytes32(bytes32(a.inverse()));\n    }\n\n    function fmul_external(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.fmul(b);\n    }\n\n    function fadd_external(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.fadd(b);\n    }\n}\n"
    },
    "contracts/testing_contracts/public_coin_tester.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport '../public_coin.sol';\n\n\ncontract PublicCoinTesting {\n    using PublicCoin for PublicCoin.Coin;\n    event log_bytes32(bytes32 data);\n\n    // Reads a number of elements after initing to a starting value\n    function init_and_read(bytes calldata starting_data, uint256 number) external {\n        PublicCoin.Coin memory coin = PublicCoin.init_coin(starting_data);\n\n        for (uint256 i = 0; i < number; i++) {\n            bytes32 read = coin.read_bytes32();\n            emit log_bytes32(read);\n        }\n    }\n\n    // Creates a channel, writes to it and then returns the digest\n    function init_and_write(bytes calldata starting_data, bytes32 data) external {\n        PublicCoin.Coin memory coin = PublicCoin.init_coin(starting_data);\n        coin.write_bytes32(data);\n        emit log_bytes32(coin.digest);\n    }\n}\n"
    },
    "contracts/testing_contracts/recurance.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/ConstraintInterface.sol';\nimport '../public_coin.sol';\nimport '../proof_types.sol';\nimport '../utils.sol';\nimport '../primefield.sol';\nimport '../iterator.sol';\n\n\n// This trivial Fibonacci system returns constant values which are true only for one proof\n// It should only be used for testing purposes\ncontract Recurance is ConstraintSystem {\n    using Iterators for Iterators.IteratorUint;\n    using PrimeField for uint256;\n    using PrimeField for PrimeField.EvalX;\n    using Utils for *;\n\n    struct PublicInput {\n        uint256 value;\n        uint64 index;\n    }\n\n    struct ProofData {\n        uint256[] trace_values;\n        PrimeField.EvalX eval;\n        uint256[] constraint_values;\n        uint256[] trace_oods_values;\n        uint256[] constraint_oods_values;\n        uint8 log_trace_length;\n    }\n\n    uint8 NUM_COLUMNS = 2;\n    uint8 CONSTRAINT_DEGREE = 2;\n\n    // These constants are derived from the small fib example in rust\n    // TODO - The solidity prettier wants to delete all 'override' statements\n    // We should remove this ignore statement when that changes.\n    // prettier-ignore\n    function initalize_system(bytes calldata public_input)\n        external\n        view\n        override\n        returns (ProofTypes.ProofParameters memory, PublicCoin.Coin memory)\n    {\n        PublicInput memory input = abi.decode(public_input, (PublicInput));\n        PublicCoin.Coin memory coin = PublicCoin.Coin({\n            digest: keccak256(abi.encodePacked(input.index, input.value, uint64(2))),\n            counter: 0\n        });\n        // The trace length is going to be the next power of two after index.\n        uint8 log_trace_length = Utils.num_bits(input.index) + 1;\n        uint8[] memory fri_layout = default_fri_layout(log_trace_length);\n\n        ProofTypes.ProofParameters memory params = ProofTypes.ProofParameters({\n            number_of_columns: NUM_COLUMNS,\n            log_trace_length: log_trace_length,\n            number_of_constraints: 4,\n            log_blowup: 4,\n            constraint_degree: CONSTRAINT_DEGREE,\n            pow_bits: 10,\n            number_of_queries: 20,\n            fri_layout: fri_layout\n        });\n\n        return (params, coin);\n    }\n\n    // TODO - Move this to a util file or default implementation\n    uint8 LOG2_TARGET = 8;\n\n    // This function produces the default fri layout from the trace length\n    function default_fri_layout(uint8 log_trace_len) internal view returns (uint8[] memory) {\n        uint256 num_reductions;\n        if (log_trace_len > LOG2_TARGET) {\n            num_reductions = log_trace_len - LOG2_TARGET;\n        } else {\n            num_reductions = log_trace_len;\n        }\n\n        uint8[] memory result;\n        if (num_reductions % 3 != 0) {\n            result = new uint8[](1 + (num_reductions / 3));\n            result[result.length - 1] = uint8(num_reductions % 3);\n        } else {\n            result = new uint8[](num_reductions / 3);\n        }\n        for (uint256 i = 0; i < (num_reductions / 3); i++) {\n            result[i] = 3;\n        }\n        return result;\n    }\n\n    // prettier-ignore\n    function constraint_calculations(\n        ProofTypes.StarkProof calldata proof,\n        ProofTypes.ProofParameters calldata params,\n        uint64[] calldata queries,\n        uint256 oods_point,\n        uint256[] calldata constraint_coeffiencts,\n        uint256[] calldata oods_coeffiencts\n    ) external override returns (uint256[] memory, uint256) {\n        ProofData memory data = ProofData(proof.trace_values, PrimeField.init_eval(params.log_trace_length + 4), proof.constraint_values, proof.trace_oods_values, proof.constraint_oods_values, params.log_trace_length);\n        PublicInput memory input = abi.decode(proof.public_inputs, (PublicInput));\n        uint256[] memory result = get_polynomial_points(data, oods_coeffiencts, queries, oods_point);\n\n        // for (uint256 i = 0; i < result.length; i++) {\n        //     console.logBytes32((bytes32)(result[i]));\n        // }\n\n        uint256 evaluated_point = evaluate_oods_point(oods_point, constraint_coeffiencts, data.eval, input, data);\n        // console.logBytes32((bytes32)(evaluated_point));\n        return (result, evaluated_point);\n    }\n\n    // (Trace(0, 1) - Trace(1, 0).pow(self.exponent)) * every_row(),\n    // (Trace(1, 1) - Trace(0, 0) - Trace(1, 0)) * every_row(),\n    // (Trace(0, 0) - 1.into()) * on_row(trace_length),\n    // (Trace(0, 0) - (&self.value).into()) * on_row(self.index),\n    // TODO - Use batch inversion\n    function evaluate_oods_point(uint256 oods_point, uint256[] memory constraint_coeffiencts, PrimeField.EvalX memory eval, PublicInput memory public_input, ProofData memory data) internal returns(uint256) {\n        uint256 trace_length = uint256(1) << data.log_trace_length;\n        // Note the blowup is fixed in this contract\n        uint256 trace_generator = eval.eval_domain_generator.fpow(16);\n        // NOTE - Constraint degree is fixed in this system\n        uint256 target_degree = 2*trace_length - 1; // 511\n        uint256 non_mont_oods = oods_point.fmul_mont(1);\n\n        uint256 result = 0;\n        {\n            //  (X.pow(trace_length) - 1.into())\n            // Non mont form because the inverse is in native form\n            // NOTE - Stack depth errors prevent this from being spread\n            uint256 every_row_denom = (non_mont_oods.fpow(trace_length)).fsub(1);\n            every_row_denom = every_row_denom.inverse();\n            uint256 every_row_numb = non_mont_oods.fsub(trace_generator.fpow(trace_length - 1));\n            // First constraint calculation block\n            {\n                uint256 adjustment;\n                {\n                    //\n                    uint256 adjustment_every_row_2 = non_mont_oods.fpow(degree_adjustment(target_degree, 2*trace_length - 1, trace_length));\n                    // console.log(\"Adjustment degree\");\n                    // console.log(degree_adjustment(target_degree, 2*trace_length - 1, trace_length));\n                    // console.logBytes32((bytes32)(adjustment_every_row_2));\n                    adjustment = constraint_coeffiencts[1].fmul(adjustment_every_row_2);\n                    adjustment = adjustment.fadd(constraint_coeffiencts[0]);\n                    // console.logBytes32((bytes32)(adjustment));\n                }\n                uint256 cell_squared = data.trace_oods_values[2].fmul_mont(data.trace_oods_values[2]);\n                // console.logBytes32((bytes32)(cell_squared.from_montgomery()));\n                uint256 constraint_eval = data.trace_oods_values[1].fsub(cell_squared);\n                // console.logBytes32((bytes32)(every_row_numb.to_montgomery()));\n                // console.logBytes32((bytes32)(every_row_denom));\n                constraint_eval = constraint_eval.fmul(every_row_numb);\n                constraint_eval = constraint_eval.fmul(every_row_denom);\n                // console.logBytes32((bytes32)(constraint_eval));\n                result = adjustment.fmul_mont(constraint_eval);\n            }\n            // console.log(\"After first calculation\");\n            // console.logBytes32((bytes32)(result));\n            // Second constraint calculation block\n            {\n\n                uint256 adjustment;\n                {\n                    uint256 adjustment_every_row_1 = non_mont_oods.fpow(degree_adjustment(target_degree, trace_length, trace_length));\n                    adjustment = constraint_coeffiencts[3].fmul(adjustment_every_row_1);\n                    adjustment = adjustment.fadd(constraint_coeffiencts[2]);\n                }\n                uint256 constraint_eval = data.trace_oods_values[3].fsub(data.trace_oods_values[0]);\n                constraint_eval = constraint_eval.fsub(data.trace_oods_values[2]);\n                constraint_eval = constraint_eval.fmul(every_row_numb);\n                constraint_eval = constraint_eval.fmul(every_row_denom);\n                result = result.fadd(adjustment.fmul_mont(constraint_eval));\n            }\n            // console.log(\"After second calculation\");\n            // console.logBytes32((bytes32)(result));\n\n        }\n        {\n            uint256 adjustment_fixed_row = non_mont_oods.fpow(degree_adjustment(target_degree, trace_length-1, 1));\n            {\n                uint256 constraint_eval = data.trace_oods_values[0].fsub((uint256(1).to_montgomery()));\n                // TODO - Just make that one?\n                uint256 last_row_denom = (non_mont_oods.fsub(trace_generator.fpow(trace_length))).inverse();\n                constraint_eval = constraint_eval.fmul(last_row_denom);\n                uint256 adjustment = constraint_coeffiencts[5].fmul(adjustment_fixed_row);\n                adjustment = adjustment.fadd(constraint_coeffiencts[4]);\n                result = result.fadd(adjustment.fmul_mont(constraint_eval));\n            }\n\n            // console.log(\"After third calculation\");\n            // console.logBytes32((bytes32)(result));\n\n            {\n                uint256 constraint_eval = data.trace_oods_values[0].fsub(public_input.value);\n                uint256 index_row_denom = non_mont_oods.fsub(trace_generator.fpow(public_input.index));\n                index_row_denom = index_row_denom.inverse();\n                constraint_eval = constraint_eval.fmul(index_row_denom);\n                uint256 adjustment = constraint_coeffiencts[7].fmul(adjustment_fixed_row);\n                adjustment = adjustment.fadd(constraint_coeffiencts[6]);\n                result = result.fadd(adjustment.fmul_mont(constraint_eval));\n            }\n\n            // console.log(\"After fourth calculation\");\n            // console.logBytes32((bytes32)(result));\n        }\n        return result;\n    }\n\n    function degree_adjustment(uint256 target_degree, uint256 numerator_degree, uint256 denominator_degree) internal pure returns(uint256) {\n        return target_degree + denominator_degree - numerator_degree;\n      }\n\n    // This function calcluates the adjustments to each query point which are implied\n    // by the offsets and degree of the constraint system\n    // It returns the low degree polynomial points at the query indcies\n    function get_polynomial_points(\n        ProofData memory data,\n        uint256[] memory oods_coeffiecients,\n        uint64[] memory queries,\n        uint256 oods_point\n    ) internal returns(uint256[] memory) {\n        uint256[] memory inverses = oods_prepare_inverses(queries, data.eval, oods_point, data.log_trace_length + 4, data.log_trace_length);\n        uint256[] memory results = new uint256[](queries.length);\n        // Init an iterator over the oods coeffiecients\n        Iterators.IteratorUint memory coeffiecients = Iterators.init_iterator(oods_coeffiecients);\n\n        for (uint256 i = 0; i < queries.length; i++) {\n            uint256 result = 0;\n            // Num col * num_rows [note this relation won't hold in other contraint systems]\n            uint256 len = NUM_COLUMNS*2;\n            for (uint256 j = 0; j < len; j++) {\n                // console.log(\"Trace query\");\n                // console.logBytes32((bytes32)(data.trace_values[i+j/2]));\n                // console.log(\"oods value\");\n                // console.logBytes32((bytes32)(data.trace_oods_values[j]));\n                // console.log(\"index\", i);\n                uint256 numberator = data.trace_values[i*2+j/2].fsub(data.trace_oods_values[j]);\n                // console.log(\"Numberator\");\n                // console.logBytes32((bytes32)(numberator));\n                uint256 denominator_inv = inverses[i*3 + (j%2)];\n                // console.log(\"denominator_inv\");\n                // console.logBytes32((bytes32)(denominator_inv));\n                uint256 element = numberator.fmul(denominator_inv);\n                // console.log(\"element\");\n                // console.logBytes32((bytes32)(element));\n                uint256 coef = coeffiecients.next();\n                // console.log(\"coef\");\n                // console.logBytes32((bytes32)(coef));\n                uint256 next_term = element.fmul_mont(coef);\n                // console.log(\"next_term\");\n                // console.logBytes32((bytes32)(next_term));\n                result = result.fadd(next_term);\n                // console.log(\"result\");\n                // console.logBytes32((bytes32)(result));\n            }\n            // console.log(\"\");\n\n            uint256 denominator_inv = inverses[i*3 + 2];\n            len = CONSTRAINT_DEGREE;\n            for (uint256 j = 0; j < len; j++) {\n                uint256 numberator = data.constraint_values[i*len + j].fsub(data.constraint_oods_values[j]);\n                uint256 element = numberator.fmul(denominator_inv);\n                // console.log(\"element\");\n                // console.logBytes32((bytes32)(element));\n\n                uint256 coef = coeffiecients.next();\n                // console.log(\"coef\");\n                // console.logBytes32((bytes32)(coef));\n                uint256 next_term = element.fmul_mont(coef);\n                result = result.fadd(next_term);\n            }\n\n            results[i] = result;\n            // This resets the iterator to start from the begining again\n            coeffiecients.index = 0;\n        }\n\n        return results;\n    }\n\n    // TODO - Make batch invert a function\n    // TODO - Attempt to make batch invert work in place\n    // Note - This function should be auto generated along\n    // TODO - Make generic over a constant trace layout, will that work with complex systems?\n    function oods_prepare_inverses(uint64[] memory queries, PrimeField.EvalX memory eval, uint256 oods_point, uint8 log_eval_domain_size, uint8 log_trace_len)\n        internal\n        returns (uint256[] memory)\n    {\n        oods_point = oods_point.from_montgomery();\n        uint256 trace_generator = eval.eval_domain_generator.fpow(16);\n        uint256[] memory batch_in = new uint256[](3 * queries.length);\n        // For each query we we invert several points used in the calculation of\n        // the commited polynomial.\n        for (uint256 i = 0; i < queries.length; i++) {\n            // Get the shifted eval point\n            uint256 x = eval.lookup(queries[i].bit_reverse(log_eval_domain_size)).fmul(PrimeField.GENERATOR);\n            // Preparing denominator for row 0\n            // This is the shifted x - trace_generator^(0)\n            batch_in[3 * i + 0] = x.fsub(oods_point.fmul(uint256(1)));\n            // Preparing denominator for row 1\n            // This is the shifted x - trace_generator^(1)\n            batch_in[3 * i + 1] = x.fsub(oods_point.fmul(trace_generator));\n            // This is the shifted x - oods_point^(degree)\n            batch_in[3 * i + 2] = x.fsub(oods_point.fmul(oods_point));\n        }\n\n        uint256[] memory batch_out = new uint256[](batch_in.length);\n        uint256 carried = 1;\n        for (uint256 i = 0; i < batch_in.length; i++) {\n            carried = carried.fmul(batch_in[i]);\n            batch_out[i] = carried;\n        }\n\n        uint256 inv_prod = carried.inverse();\n\n        for (uint256 i = batch_out.length - 1; i > 0; i--) {\n            batch_out[i] = inv_prod.fmul(batch_out[i-1]);\n            inv_prod = inv_prod.fmul(batch_in[i]);\n        }\n        batch_out[0] = inv_prod;\n        return batch_out;\n    }\n}\n"
    },
    "contracts/testing_contracts/stark_digest_tester.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport '../stark_verifier.sol';\n\n\n// These tests are intermeridary tests in the verification of the stark proof,\n// if the functions change they will have to change too. Unfortunately, it is\n// dificult to get access to data in any other way inside of a verify_proof call.\ncontract StarkDigestTesting is StarkVerifier {\n    // Takes a proof and returns the coin digest after reading and writing\n    function digest_read(StarkProof memory proof, ConstraintSystem constraints) public view returns (bytes32) {\n        (ProofParameters memory constraint_parameters, PublicCoin.Coin memory coin) = constraints.initalize_system(\n            proof.public_inputs\n        );\n        // Write data to the coin and read random data from it\n        write_data_and_read_random(proof, constraint_parameters, coin);\n        return coin.digest;\n    }\n\n    // Takes a proof and returns the queries after reading and writing\n    function queries_read(StarkProof memory proof, ConstraintSystem constraints) public view returns (uint64[] memory) {\n        (ProofParameters memory constraint_parameters, PublicCoin.Coin memory coin) = constraints.initalize_system(\n            proof.public_inputs\n        );\n        // Write data to the coin and read random data from it\n        write_data_and_read_random(proof, constraint_parameters, coin);\n        // Preform the proof of work check\n        require(check_proof_of_work(coin, proof.pow_nonce, constraint_parameters.pow_bits), 'POW Failed');\n        // Read the query indecies from the coin\n        uint8 eval_domain_log_size = constraint_parameters.log_trace_length + constraint_parameters.log_blowup;\n        uint64[] memory queries = get_queries(coin, eval_domain_log_size, constraint_parameters.number_of_queries);\n        return queries;\n    }\n}\n"
    },
    "contracts/testing_contracts/trivial_fib.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/ConstraintInterface.sol';\nimport '../public_coin.sol';\nimport '../proof_types.sol';\n\n\n// This trivial Fibonacci system returns constant values which are true only for one proof\n// It should only be used for testing purposes\ncontract TrivialFib is ConstraintSystem {\n    // These constants are derived from the small fib example in rust\n    // TODO - The solidity prettier wants to delete all 'override' statements\n    // We should remove this ignore statement when that changes.\n    // prettier-ignore\n    function initalize_system(bytes calldata public_input)\n        external\n        view\n        override\n        returns (ProofTypes.ProofParameters memory, PublicCoin.Coin memory)\n    {\n        PublicCoin.Coin memory coin = PublicCoin.Coin({\n            digest: 0xc891a11ddbc6c425fad523a7a4aeafa505d7aa1638cfffbd5b747100bc69e367,\n            counter: 0\n        });\n        uint8[] memory fri_layout = new uint8[](3);\n        fri_layout[0] = 3;\n        fri_layout[1] = 3;\n        fri_layout[2] = 2;\n\n        ProofTypes.ProofParameters memory params = ProofTypes.ProofParameters({\n            number_of_columns: 2,\n            log_trace_length: 10,\n            number_of_constraints: 4,\n            log_blowup: 4,\n            constraint_degree: 1,\n            pow_bits: 10,\n            number_of_queries: 20,\n            fri_layout: fri_layout\n        });\n\n        return (params, coin);\n    }\n\n    // prettier-ignore\n    function constraint_calculations(\n        ProofTypes.StarkProof calldata proof,\n        ProofTypes.ProofParameters calldata params,\n        uint64[] calldata queries,\n        uint256 oods_point,\n        uint256[] calldata constraint_coeffiencts,\n        uint256[] calldata oods_coeffiencts\n    ) external override returns (uint256[] memory, uint256) {\n        uint256[20] memory data = [\n            0x0278847872d28b671420b700e8472b61d6846def99dbf99a7a5399322e5a2b25,\n            0x067cda05602e614e2c1b223c79da8baebac06b2d292fefb80ea4e86e18f943bc,\n            0x00c675c55829b7a6c183dde1223e93478d6b70c26bcc2201889e1b7887fe6aed,\n            0x020c9a64e2b4c00045aea9a87b1164a50466eabd2cfe73384cf9bebd790b20b0,\n            0x017228952dfaed74882b395e72518fc0a62f850a1988d663d3bc71be2ac0fa17,\n            0x052108c7d4c28ce004ab79e110fb3cdc47d2ac50fb98de8ce04472ac67198a1d,\n            0x05f492f33d6193afbb51b02b931c1aa08ae75af0893b20a46e5061fab952098d,\n            0x06a0f45dfaf230e64f2bf379bd3c98f21420bddd9b8fef9e9c65f7486c6d5046,\n            0x00262047cab1f998fb5707c6eee44b246e4ef011d2832eb289b708be2c1368d6,\n            0x04ab8123e26adcb3dbd198991ab1e9b435712c26a246ef5396911e1e29d55d33,\n            0x02fb6d73ed2f683e39d10a47b8419dcc4a8fd38826e84ec526768fae221e71a9,\n            0x00e969f57d6c8591abe24b6e44060e01ac72555c00f7f9c5811dd02d857435a3,\n            0x0069ebcf5161ea303c183fe4a92d6ff06343bca3cd382792aeb4a1b43c6610f5,\n            0x01f7f5804a45c9da2940a323ca6edf93dab8b19a08917392951306162f45cfaa,\n            0x07ffc4537e1b3c8f709413fbec183286e663878fb43cb6c58d15f618f91dcae8,\n            0x06cfe5f951759fdfaf0affdef0fc822396baae1090e579bc18a20c154c4dd97b,\n            0x033028e4c3a950389e9e219d624acecc8d8c201f27005335ec487fb8decca1e8,\n            0x00624958789bc7d55270e20d9abe2ab66e58f9713af2cf0a3a6feba91c514506,\n            0x02ba418d91252465917e8e1f6126194005b06abc1739036c1068ebef512a7536,\n            0x0714fd690cb3ef6d859113829d892187b2a6300949e3fca261214473632e5559\n        ];\n\n        // Soldity really needs better conversions\n        uint256[] memory result = new uint256[](20);\n        for (uint256 i = 0; i < 20; i++) {\n            result[i] = data[i];\n        }\n        return (result, 0x01e94b626dcff9d77c33c75b33d8457ba91534da30442d41d717a06e3f65211d);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}